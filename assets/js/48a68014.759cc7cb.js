"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[670],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,f=d["".concat(l,".").concat(h)]||d[h]||p[h]||i;return n?o.createElement(f,a(a({ref:t},u),{},{components:n})):o.createElement(f,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3171:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return a},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return c}});var o=n(3117),r=(n(7294),n(3905));const i={},a="OpenID Connect (OIDC)",s={unversionedId:"auth/oidc",id:"auth/oidc",title:"OpenID Connect (OIDC)",description:"OpenID Connect (OIDC) is an identity layer on top of the OAuth 2.0 protocol. It allows Clients to",source:"@site/docs/auth/oidc.md",sourceDirName:"auth",slug:"/auth/oidc",permalink:"/docs/auth/oidc",draft:!1,editUrl:"https://github.com/niomon/niomon-docs/blob/main/docs/auth/oidc.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Niomon Auth",permalink:"/docs/auth"},next:{title:"Sign-In with Ethereum",permalink:"/docs/auth/siwe"}},l={},c=[{value:"OIDC vs OAuth2",id:"oidc-vs-oauth2",level:2},{value:"Tokens",id:"tokens",level:2},{value:"OIDC Flows",id:"oidc-flows",level:2},{value:"OIDC Discovery",id:"oidc-discovery",level:2},{value:"Signing algorithms for JWTs",id:"signing-algorithms-for-jwts",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"openid-connect-oidc"},"OpenID Connect (OIDC)"),(0,r.kt)("p",null,"OpenID Connect (OIDC) is an identity layer on top of the OAuth 2.0 protocol. It allows Clients to\nverify the identity of the End-User based on the authentication performed by an Authorization\nServer, as well as to obtain basic profile information about the End-User in an interoperable and\nREST-like manner."),(0,r.kt)("h2",{id:"oidc-vs-oauth2"},"OIDC vs OAuth2"),(0,r.kt)("p",null,"While OAuth 2.0 is about resource access and sharing, OIDC is about user authentication."),(0,r.kt)("p",null,"OIDC uses OAuth 2.0 as an underlying protocol and adds a few extensions on top of it. It adds a\nspecial scope value (",(0,r.kt)("inlineCode",{parentName:"p"},"openid"),"), the use of an extra token (the ID Token, which encapsulates the\nidentity claims in JSON format), and the emphasis on authentication rather than authorization.\nAlso, in OIDC, the term \u201cflow\u201d is used in place of OAuth2 \u201cgrant\u201d"),(0,r.kt)("h2",{id:"tokens"},"Tokens"),(0,r.kt)("p",null,"An OIDC provider (normally called the Identity Provider or IdP) performs user authentication, user\nconsent, and token issuance. The client or service requesting a user's identity is normally called\nthe Relying Party (RP). It can be a regular web application, a single-page web app, or a mobile\napp."),(0,r.kt)("p",null,"OpenID uses several types of tokens on top of OAuth 2.0 to provide a simple identity layer. This\nincludes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ID Token"),": Specific to OIDC, this JWT format token provides the identity data describing a\nuser profile. The data about the authentication result and the user profile information are\ncalled claims. The user profile claims may be any data that is pertinent to the Relying Party\nfor identification purposes, such as a persistent ID, email address, name, etc. ID Tokens are\ndigitally signed to prevent tampering.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Access Token"),": Defined in OAuth2, this (optional) short lifetime token provides access to\nspecific user resources as defined in the scope values in the request to the authorization\nserver.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Refresh Token"),": Defined in OAuth2, this token is usually long-lived and may be used to\nobtain new access tokens."))),(0,r.kt)("h2",{id:"oidc-flows"},"OIDC Flows"),(0,r.kt)("p",null,"OIDC defines several authentication flows for different types of applications and security\nrequirements. Niomon supports the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Authorization Code Flow"),": In this flow, tokens are not returned directly to the client.\nInstead, the server exchanges an Authorization Code for a token using a Client Secret."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Authorization Code Flow with PKCE"),": For public clients (e.g. single-page or mobile apps),\nthe ",(0,r.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/rfc7636"},"Proof Key for Code Exchange")," (PKCE) flow is used\ninstead. This flow adds a secret (the Code Verifier) created by the client application that can\nbe verified by the authorization server.")),(0,r.kt)("h2",{id:"oidc-discovery"},"OIDC Discovery"),(0,r.kt)("p",null,"Niomon Auth supports the OIDC Discovery mechanism. The discovery document is located at:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"https://api.niomonid.com/YOUR_TENANT/.well-known/openid-configuration\n")),(0,r.kt)("h2",{id:"signing-algorithms-for-jwts"},"Signing algorithms for JWTs"),(0,r.kt)("p",null,"Niomon Auth uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"ES256")," algorithm (ECDSA using P-256 curve and SHA-256 hash algorithm) for\nJWTs by default."),(0,r.kt)("p",null,"The public key of Niomon Auth can be found on the JSON Web Key Set document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"https://api.niomonid.com/YOUR_TENANT/.well-known/openid-configuration\n")))}p.isMDXComponent=!0}}]);